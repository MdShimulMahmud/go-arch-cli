package generator

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

// -------------------- Public --------------------

func PreviewStructure(arch string) string {
	switch arch {
	case "flat":
		return previewFlat()
	case "ddd":
		return previewDDD()
	case "clean":
		return previewClean()
	case "feature":
		return previewFeature()
	case "hexagonal":
		return previewHexagonal()
	case "modular":
		return previewModular()
	case "monorepo":
		return previewMonorepo()
	case "cqrs":
		return previewCQRS()
	case "onion":
		return previewOnion()
	case "common":
		return previewCommon()
	case "layered":
		return previewLayered()
	default:
		return fmt.Sprintf("Unsupported architecture: %s", arch)
	}
}

func GenerateProject(arch, module string) error {
	switch arch {
	case "flat":
		return generateFlat(module)
	case "ddd":
		return generateDDD(module)
	case "clean":
		return generateClean(module)
	case "feature":
		return generateFeature(module)
	case "hexagonal":
		return generateHexagonal(module)
	case "modular":
		return generateModular(module)
	case "monorepo":
		return generateMonorepo(module)
	case "cqrs":
		return generateCQRS(module)
	case "onion":
		return generateOnion(module)
	case "common":
		return generateCommon(module)
	case "layered":
		return generateLayered(module)
	default:
		return fmt.Errorf("unsupported architecture: %s", arch)
	}
}

// -------------------- Helpers --------------------

func createTree(files []string, projectName string) string {
	// Create a tree structure map
	tree := make(map[string][]string)
	allDirs := make(map[string]bool)

	// Build directory structure
	for _, file := range files {
		parts := strings.Split(filepath.ToSlash(file), "/")
		currentPath := ""

		for i, part := range parts {
			if currentPath == "" {
				currentPath = part
			} else {
				currentPath = currentPath + "/" + part
			}

			if i == 0 {
				// Root level
				if !contains(tree[""], part) {
					tree[""] = append(tree[""], part)
				}
			} else {
				// Nested level
				parentPath := strings.Join(parts[:i], "/")
				if !contains(tree[parentPath], part) {
					tree[parentPath] = append(tree[parentPath], part)
				}
			}

			// Mark as directory if it's not the last part or if it ends with /
			if i < len(parts)-1 || strings.HasSuffix(file, "/") {
				allDirs[currentPath] = true
			}
		}
	}

	// Generate tree output
	var result strings.Builder
	result.WriteString(fmt.Sprintf("%s/\n", projectName))

	// Sort root level items
	rootItems := tree[""]
	sortedItems := make([]string, len(rootItems))
	copy(sortedItems, rootItems)

	for i, item := range sortedItems {
		isLast := i == len(sortedItems)-1
		result.WriteString(buildTreeBranch(item, "", isLast, tree, allDirs))
	}

	return result.String()
}

func buildTreeBranch(item, parentPath string, isLast bool, tree map[string][]string, allDirs map[string]bool) string {
	var result strings.Builder

	prefix := "├── "
	childPrefix := "│   "
	if isLast {
		prefix = "└── "
		childPrefix = "    "
	}

	// Add current item
	result.WriteString(fmt.Sprintf("%s%s", prefix, item))

	// Add trailing slash for directories
	currentPath := item
	if parentPath != "" {
		currentPath = parentPath + "/" + item
	}

	if allDirs[currentPath] {
		result.WriteString("/")
	}
	result.WriteString("\n")

	// Add children if any
	children := tree[currentPath]
	for j, child := range children {
		isChildLast := j == len(children)-1
		childBranch := buildTreeBranch(child, currentPath, isChildLast, tree, allDirs)
		// Add prefix to each line of child branch
		lines := strings.Split(strings.TrimSuffix(childBranch, "\n"), "\n")
		for _, line := range lines {
			result.WriteString(childPrefix + line + "\n")
		}
	}

	return result.String()
}

func contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}

func writeFiles(dir string, files []string) error {
	for _, f := range files {
		path := filepath.Join(dir, f)
		if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {
			return err
		}
		if _, err := os.Create(path); err != nil {
			return err
		}
	}
	return nil
}

func runGoModInit(dir, module string) error {
	cmd := exec.Command("go", "mod", "init", module)
	cmd.Dir = dir
	return cmd.Run()
}

func writeREADME(dir, arch, module string) error {
	content := fmt.Sprintf("# %s\n\nThis project uses the **%s architecture**.\n\nGenerated by go-arch-cli.\n", module, arch)
	return os.WriteFile(filepath.Join(dir, "README.md"), []byte(content), 0644)
}

func writeGitignore(dir string) error {
	content := "bin/\nvendor/\n*.exe\n*.out\n*.test\n*.log\n"
	return os.WriteFile(filepath.Join(dir, ".gitignore"), []byte(content), 0644)
}

func writeMainStarter(path, arch string) error {
	content := fmt.Sprintf(`package main

import "fmt"

func main() {
	fmt.Println("Hello from %s project!")
}
`, arch)
	return os.WriteFile(path, []byte(content), 0644)
}

func writeLibraryFiles(dir string) error {
	// Write logging library
	loggerContent := `package logging

import "log"

// Logger provides structured logging
type Logger struct{}

// Info logs an info message
func (l *Logger) Info(msg string) {
	log.Println("[INFO]", msg)
}

// Error logs an error message
func (l *Logger) Error(msg string) {
	log.Println("[ERROR]", msg)
}
`
	if err := os.WriteFile(filepath.Join(dir, "libs/logging/logger.go"), []byte(loggerContent), 0644); err != nil {
		return err
	}

	// Write authentication library
	authContent := `package authentication

// Auth provides authentication utilities
type Auth struct{}

// Validate validates a token
func (a *Auth) Validate(token string) bool {
	// TODO: Implement token validation
	return len(token) > 0
}
`
	if err := os.WriteFile(filepath.Join(dir, "libs/authentication/auth.go"), []byte(authContent), 0644); err != nil {
		return err
	}

	// Write utils library
	utilsContent := `package utils

// StringHelper provides string utilities
func StringHelper() string {
	return "Helper functions"
}
`
	if err := os.WriteFile(filepath.Join(dir, "libs/utils/helpers.go"), []byte(utilsContent), 0644); err != nil {
		return err
	}

	return nil
}

func writeMonorepoServiceFiles(dir string) error {
	// User handler
	handlerContent := `package handler

import (
	"encoding/json"
	"net/http"
)

type UserHandler struct{}

func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {
	user := map[string]string{"name": "John Doe", "email": "john@example.com"}
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(user)
}
`
	if err := os.WriteFile(filepath.Join(dir, "services/user-service/internal/handler/user_handler.go"), []byte(handlerContent), 0644); err != nil {
		return err
	}

	// User service
	serviceContent := `package service

type User struct {
	ID    int    ` + "`json:\"id\"`" + `
	Name  string ` + "`json:\"name\"`" + `
	Email string ` + "`json:\"email\"`" + `
}

type UserService struct{}

func (s *UserService) GetUser(id int) (*User, error) {
	// TODO: Implement user retrieval logic
	return &User{ID: id, Name: "John Doe", Email: "john@example.com"}, nil
}
`
	if err := os.WriteFile(filepath.Join(dir, "services/user-service/internal/service/user_service.go"), []byte(serviceContent), 0644); err != nil {
		return err
	}

	// User repository
	repoContent := `package repository

import "errors"

type UserRepository struct{}

func (r *UserRepository) FindByID(id int) (map[string]interface{}, error) {
	if id <= 0 {
		return nil, errors.New("invalid user ID")
	}
	// TODO: Implement database logic
	return map[string]interface{}{
		"id":    id,
		"name":  "John Doe",
		"email": "john@example.com",
	}, nil
}
`
	if err := os.WriteFile(filepath.Join(dir, "services/user-service/internal/repository/user_repository.go"), []byte(repoContent), 0644); err != nil {
		return err
	}

	// User models
	modelsContent := `package models

type User struct {
	ID       int    ` + "`json:\"id\" db:\"id\"`" + `
	Name     string ` + "`json:\"name\" db:\"name\"`" + `
	Email    string ` + "`json:\"email\" db:\"email\"`" + `
	Password string ` + "`json:\"-\" db:\"password\"`" + `
}
`
	if err := os.WriteFile(filepath.Join(dir, "services/user-service/internal/models/user.go"), []byte(modelsContent), 0644); err != nil {
		return err
	}

	return nil
}

// -------------------- Architectures --------------------

func generateFlat(module string) error {
	dir := "project_flat"
	files := []string{"main.go", "handler.go", "service.go", "repository.go", "config.go", "utils.go"}
	os.MkdirAll(dir, 0755)
	writeFiles(dir, files)
	writeMainStarter(filepath.Join(dir, "main.go"), "Flat")
	writeREADME(dir, "Flat", module)
	writeGitignore(dir)
	return runGoModInit(dir, module)
}

func generateDDD(module string) error {
	dir := "project_ddd"
	files := []string{
		"cmd/app/main.go",
		"internal/user/handler.go",
		"internal/user/service.go",
		"internal/user/repository.go",
		"internal/user/user.go",
		"internal/product/handler.go",
		"internal/product/service.go",
		"internal/product/repository.go",
	}
	os.MkdirAll(dir, 0755)
	writeFiles(dir, files)
	writeMainStarter(filepath.Join(dir, "cmd/app/main.go"), "DDD")
	writeREADME(dir, "DDD", module)
	writeGitignore(dir)
	return runGoModInit(dir, module)
}

func generateClean(module string) error {
	dir := "project_clean"
	files := []string{
		"cmd/app/main.go",
		"internal/entities/user.go",
		"internal/usecases/user_service.go",
		"internal/repository/user_repo.go",
		"internal/delivery/http/user_handler.go",
	}
	os.MkdirAll(dir, 0755)
	writeFiles(dir, files)
	writeMainStarter(filepath.Join(dir, "cmd/app/main.go"), "Clean")
	writeREADME(dir, "Clean", module)
	writeGitignore(dir)
	return runGoModInit(dir, module)
}

func generateFeature(module string) error {
	dir := "project_feature"
	files := []string{
		"cmd/app/main.go",
		"internal/user/handler/user_handler.go",
		"internal/user/service/user_service.go",
		"internal/user/repository/user_repo.go",
		"internal/user/user.go",
		"internal/product/handler/product_handler.go",
		"internal/product/service/product_service.go",
		"internal/product/repository/product_repo.go",
		"internal/product/product.go",
		"pkg/logger.go",
	}
	os.MkdirAll(dir, 0755)
	writeFiles(dir, files)
	writeMainStarter(filepath.Join(dir, "cmd/app/main.go"), "Feature-Based")
	writeREADME(dir, "Feature-Based", module)
	writeGitignore(dir)
	return runGoModInit(dir, module)
}

func generateHexagonal(module string) error {
	dir := "project_hexagonal"
	files := []string{
		"cmd/app/main.go",
		"internal/core/user/entity.go",
		"internal/core/user/usecase.go",
		"internal/adapters/database/user_repo.go",
		"internal/adapters/api/user_handler.go",
		"internal/ports/user_repository.go",
		"internal/ports/user_service.go",
	}
	os.MkdirAll(dir, 0755)
	writeFiles(dir, files)
	writeMainStarter(filepath.Join(dir, "cmd/app/main.go"), "Hexagonal")
	writeREADME(dir, "Hexagonal", module)
	writeGitignore(dir)
	return runGoModInit(dir, module)
}

func generateModular(module string) error {
	dir := "project_modular"
	files := []string{
		"user_module/handler/",
		"user_module/service/",
		"user_module/repository/",
		"user_module/user.go",
		"user_module/go.mod",
		"user_module/go.sum",
		"product_module/handler/",
		"product_module/service/",
		"product_module/repository/",
		"product_module/product.go",
		"product_module/go.mod",
		"product_module/go.sum",
		"api_gateway/main.go",
		"api_gateway/go.mod",
		"api_gateway/go.sum",
		"configs/",
	}
	os.MkdirAll(dir, 0755)
	writeFiles(dir, files)
	writeMainStarter(filepath.Join(dir, "api_gateway/main.go"), "Modular")
	writeREADME(dir, "Modular", module)
	writeGitignore(dir)
	return runGoModInit(dir, module)
}

func generateMonorepo(module string) error {
	dir := "project_monorepo"
	
	// Create basic structure first
	os.MkdirAll(dir, 0755)
	
	// Create root go.mod
	if err := runGoModInit(dir, module); err != nil {
		return fmt.Errorf("failed to initialize root go.mod: %w", err)
	}
	
	// Create service directories
	serviceDirs := []string{
		"services/user-service/cmd",
		"services/user-service/internal/handler",
		"services/user-service/internal/service",
		"services/user-service/internal/repository",
		"services/user-service/internal/models",
		"libs/logging",
		"libs/authentication",
		"libs/utils",
	}
	
	for _, serviceDir := range serviceDirs {
		if err := os.MkdirAll(filepath.Join(dir, serviceDir), 0755); err != nil {
			return fmt.Errorf("failed to create directory %s: %w", serviceDir, err)
		}
	}
	
	// Write service-specific files with content
	if err := writeMonorepoServiceFiles(dir); err != nil {
		return fmt.Errorf("failed to write service files: %w", err)
	}
	
	// Create service-specific go.mod
	serviceDir := filepath.Join(dir, "services/user-service")
	serviceModule := module + "/services/user-service"
	if err := runGoModInit(serviceDir, serviceModule); err != nil {
		return fmt.Errorf("failed to initialize service go.mod: %w", err)
	}
	
	// Write main starter file
	if err := writeMainStarter(filepath.Join(dir, "services/user-service/cmd/main.go"), "Monorepo User Service"); err != nil {
		return fmt.Errorf("failed to write main file: %w", err)
	}
	
	// Write library files
	if err := writeLibraryFiles(dir); err != nil {
		return fmt.Errorf("failed to write library files: %w", err)
	}
	
	// Write common files
	if err := writeREADME(dir, "Monorepo", module); err != nil {
		return fmt.Errorf("failed to write README: %w", err)
	}
	
	if err := writeGitignore(dir); err != nil {
		return fmt.Errorf("failed to write .gitignore: %w", err)
	}
	
	return nil
}

func generateCQRS(module string) error {
	dir := "project_cqrs"
	files := []string{
		"cmd/app/main.go",
		"internal/commands/create_user.go",
		"internal/commands/update_user.go",
		"internal/commands/delete_user.go",
		"internal/queries/get_user.go",
		"internal/repositories/user_repo.go",
		"internal/models/user.go",
		"internal/services/user_service.go",
	}
	os.MkdirAll(dir, 0755)
	writeFiles(dir, files)
	writeMainStarter(filepath.Join(dir, "cmd/app/main.go"), "CQRS")
	writeREADME(dir, "CQRS", module)
	writeGitignore(dir)
	return runGoModInit(dir, module)
}

func generateOnion(module string) error {
	dir := "project_onion"
	files := []string{
		"cmd/your-app/main.go",
		"internal/domain/entity.go",
		"internal/domain/service.go",
		"internal/application/usecase.go",
		"internal/infrastructure/persistence/repository.go",
		"internal/infrastructure/api/handler.go",
	}
	os.MkdirAll(dir, 0755)
	writeFiles(dir, files)
	writeMainStarter(filepath.Join(dir, "cmd/your-app/main.go"), "Onion")
	writeREADME(dir, "Onion", module)
	writeGitignore(dir)
	return runGoModInit(dir, module)
}

func generateCommon(module string) error {
	dir := "project_common"
	files := []string{
		"cmd/myapp/main.go",
		"internal/app/myapp/handler.go",
		"internal/app/myapp/service.go",
		"internal/pkg/myprivlib/",
		"internal/domain/entity.go",
		"internal/domain/service.go",
		"internal/infrastructure/persistence/repository.go",
		"internal/infrastructure/api/handler.go",
		"internal/infrastructure/messaging/producer.go",
		"pkg/mypubliclib/",
		"api/api_spec.yaml",
		"web/static/",
		"web/templates/",
		"configs/config.yaml",
		"init/myapp.service",
		"scripts/build.sh",
		"scripts/install.sh",
		"build/package/",
		"build/ci/",
		"deployments/kubernetes/",
		"test/data/",
		"docs/architecture.md",
		"tools/mytool/",
		"examples/example_usage.go",
		"third_party/",
		"githooks/",
		"assets/",
		"website/index.html",
	}
	os.MkdirAll(dir, 0755)
	writeFiles(dir, files)
	writeMainStarter(filepath.Join(dir, "cmd/myapp/main.go"), "Common")
	writeREADME(dir, "Common", module)
	writeGitignore(dir)
	return runGoModInit(dir, module)
}

func generateLayered(module string) error {
	dir := "project_layered"
	files := []string{
		"cmd/app/main.go",
		"internal/presentation/user_handler.go",
		"internal/service/user_service.go",
		"internal/repository/user_repo.go",
		"internal/domain/user.go",
	}
	os.MkdirAll(dir, 0755)
	writeFiles(dir, files)
	writeMainStarter(filepath.Join(dir, "cmd/app/main.go"), "Layered")
	writeREADME(dir, "Layered", module)
	writeGitignore(dir)
	return runGoModInit(dir, module)
}

// -------------------- Preview Functions --------------------

func previewFlat() string {
	files := []string{"main.go", "handler.go", "service.go", "repository.go", "config.go", "utils.go", "README.md", ".gitignore", "go.mod"}
	return createTree(files, "project_flat")
}

func previewDDD() string {
	files := []string{
		"cmd/app/main.go",
		"internal/user/handler.go",
		"internal/user/service.go",
		"internal/user/repository.go",
		"internal/user/user.go",
		"internal/product/handler.go",
		"internal/product/service.go",
		"internal/product/repository.go",
		"README.md",
		".gitignore",
		"go.mod",
	}
	return createTree(files, "project_ddd")
}

func previewClean() string {
	files := []string{
		"cmd/app/main.go",
		"internal/entities/user.go",
		"internal/usecases/user_service.go",
		"internal/repository/user_repo.go",
		"internal/delivery/http/user_handler.go",
		"README.md",
		".gitignore",
		"go.mod",
	}
	return createTree(files, "project_clean")
}

func previewFeature() string {
	files := []string{
		"cmd/app/main.go",
		"internal/user/handler/user_handler.go",
		"internal/user/service/user_service.go",
		"internal/user/repository/user_repo.go",
		"internal/user/user.go",
		"internal/product/handler/product_handler.go",
		"internal/product/service/product_service.go",
		"internal/product/repository/product_repo.go",
		"internal/product/product.go",
		"pkg/logger.go",
		"README.md",
		".gitignore",
		"go.mod",
	}
	return createTree(files, "project_feature")
}

func previewHexagonal() string {
	files := []string{
		"cmd/app/main.go",
		"internal/core/user/entity.go",
		"internal/core/user/usecase.go",
		"internal/adapters/database/user_repo.go",
		"internal/adapters/api/user_handler.go",
		"internal/ports/user_repository.go",
		"internal/ports/user_service.go",
		"README.md",
		".gitignore",
		"go.mod",
	}
	return createTree(files, "project_hexagonal")
}

func previewModular() string {
	files := []string{
		"user_module/handler/",
		"user_module/service/",
		"user_module/repository/",
		"user_module/user.go",
		"user_module/go.mod",
		"product_module/handler/",
		"product_module/service/",
		"product_module/repository/",
		"product_module/product.go",
		"product_module/go.mod",
		"api_gateway/main.go",
		"api_gateway/go.mod",
		"configs/",
		"README.md",
		".gitignore",
	}
	return createTree(files, "project_modular")
}

func previewMonorepo() string {
	files := []string{
		"services/user-service/cmd/main.go",
		"services/user-service/internal/handler/",
		"services/user-service/internal/service/",
		"services/user-service/internal/repository/",
		"services/user-service/internal/models/",
		"services/user-service/go.mod",
		"libs/logging/",
		"libs/authentication/",
		"libs/utils/",
		"go.mod",
		"README.md",
		".gitignore",
	}
	return createTree(files, "project_monorepo")
}

func previewCQRS() string {
	files := []string{
		"cmd/app/main.go",
		"internal/commands/create_user.go",
		"internal/commands/update_user.go",
		"internal/commands/delete_user.go",
		"internal/queries/get_user.go",
		"internal/repositories/user_repo.go",
		"internal/models/user.go",
		"internal/services/user_service.go",
		"README.md",
		".gitignore",
		"go.mod",
	}
	return createTree(files, "project_cqrs")
}

func previewOnion() string {
	files := []string{
		"cmd/your-app/main.go",
		"internal/domain/entity.go",
		"internal/domain/service.go",
		"internal/application/usecase.go",
		"internal/infrastructure/persistence/repository.go",
		"internal/infrastructure/api/handler.go",
		"README.md",
		".gitignore",
		"go.mod",
	}
	return createTree(files, "project_onion")
}

func previewCommon() string {
	files := []string{
		"cmd/myapp/main.go",
		"internal/app/myapp/handler.go",
		"internal/app/myapp/service.go",
		"internal/pkg/myprivlib/",
		"internal/domain/entity.go",
		"internal/domain/service.go",
		"internal/infrastructure/persistence/repository.go",
		"internal/infrastructure/api/handler.go",
		"internal/infrastructure/messaging/producer.go",
		"pkg/mypubliclib/",
		"api/api_spec.yaml",
		"web/static/",
		"web/templates/",
		"configs/config.yaml",
		"init/myapp.service",
		"scripts/build.sh",
		"scripts/install.sh",
		"build/package/",
		"build/ci/",
		"deployments/kubernetes/",
		"test/data/",
		"docs/architecture.md",
		"tools/mytool/",
		"examples/example_usage.go",
		"third_party/",
		"githooks/",
		"assets/",
		"website/index.html",
		"README.md",
		".gitignore",
		"go.mod",
	}
	return createTree(files, "project_common")
}

func previewLayered() string {
	files := []string{
		"cmd/app/main.go",
		"internal/presentation/user_handler.go",
		"internal/service/user_service.go",
		"internal/repository/user_repo.go",
		"internal/domain/user.go",
		"README.md",
		".gitignore",
		"go.mod",
	}
	return createTree(files, "project_layered")
}
